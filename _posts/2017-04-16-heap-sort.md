---
layout: post
title: Algorithm - Heap Sort
date: 2017-04-16
---

## Heap sort 힙정렬

저번에 이어서 2016년 1학기 자료구조에 나온 내용과 알고리즘 수업의 내용이 겹쳐서 함께 정리한다.
Merge sort 와 Heap sort 의 코드 모두 자료구조 수업에서 받은 것들이다.

### 그림
![Alt text](url)

### 알고리즘 설명

Merge sort 가 Divide and Conquer 를 이용한 algorithm 이라면, Heap sort 는 Heap이란 Data Structure를 이용한 algorithm이다. 따라서, Heap sort를 하기 전에 Heap이란 자료구조에 대해서 알아볼 필요가 있다.


#### Heap 이란?

1. Graph
그래프는 V와 E의 ordered pair 이며, 이 때 V 는 vertices(nodes)의 집합이며, E는 edges, 즉 unordered pairs of vertices(ordered pairs 는 arcs라고 함)의 집합이다. Graph = ( V, E)

2. Tree
Graph 중에서도 undirected, connected, acyclic 한 그래프를 Tree 라고 한다.

Tree의 node 중에서 가장 꼭대기에 있는 노드를 root라고 한다. 나머지 노드들은 서브트리로 분할될 수 있다.
Root r에서 node y 로 가는 하나의 단순한 path 에서 x를 거쳐간다면 x는 y의 parent, y는 child 이다. 

Binary Tree 즉 이진트리는 각 트리의 node가 child node를 최대 2개씩 가지고 있는 트리를 말한다.

Full Binary Tree는 맨 끝의 node를 제외한 모든 노드가 child node를 두 개씩 가지고 있는 트리를 말한다.
Complete Binary Tree는 맨 끝, 그러니까 마지막 level을 제외하고 모든 노드가 2개씩 채워진 트리이며, 마지막 node는 왼쪽에서부터 채워진 형태이다. 위-> 아래, 왼 ->오 순서를 어기지 않고 child 노드가 채워진 형태. 
왜 이런 타입을 따로 분리해놨는지 생각해보자면, Tree라는 추상적 자료구조를 컴퓨터 위에 구현하기 위해서는 숫자들인 array에 Tree 구조를 구현할 수 밖에 없기때문이겠지? 왼쪽에서부터 차있어야 array에서 구현했을 때도 각 인덱스에 tree의 어떤 node 가 들어가 있는지 예측하기 쉽기때문이다.

Heap은 Complete Binary Tree에 속한다. 여기에 Heap 만의 특성이 있는데, 바로 모든 Parent node가 Child node 보다 같거나 크다는 것이다. A(parent(i)) >= A(i) 


### 알고리즘 구현

Heap sort 알고리즘은 3가지 function 으로 구현되어 있다. 첫번째는 heapify로 하나의 노드와 그 자식들 간의 대소비교를 통해 가장 큰 값을 가진 노드를 


#### heapify

array A의 i 번째 인덱스의 노드와 그의 children을 비교해서 가장 큰 값을 가진 노드의 인덱스를 largest에 저장한뒤


#### buildheap

#### heapsort



### Time Complexity Analysis

그림 참조

