#Introduction to C programming 

# Part1 - 변수, 조건문 및 반복문

</br>



## 프로그램 작성하기 전에

### 프로그램 작성법
- // 또는 /* */ 로 커맨팅한다
- 각 문장의 끝마다 ; 를 반드시 붙여주어야 한다

### C와 함수

- C는 함수들로 구성되어 있고, 함수로 시작해서 함수로 끝난다. 
- 정해진 순서에 의해 진행되는 함수의 호출이 프로그램의 흐름이다.
- 가장 먼저 호출되는 함수는 main이며, 모든 c 프로그램에 있다.

```
#include <stdio.h> 
//printf와 같은 표준함수 호출을 위해 헤더파일 선언을 한다. 맨 앞에 와야함.
int main(void) // 출력형태 함수이름(입력형태) {함수의 몸체}
{
	printf("Hello world! \n"); 
	return 0; //함수 내 존재하는 모든 문장의 끝에는 세미콜론을 붙인다. 
}
```


## 변수, 상수 그리고 연산자


- 변수 : 값을 저장할 수 있는 메모리 공간에 붙은 이름. 이것을 통해서 메모리 공간에 접근 가능
- 변수 사용으로 연산한 뒤 값을 저장하고 저장된 값을 참조할 수 있음


### 변수의 선언
```
int num; //num이라는 이름의, int 타입의 변수를 선언
```
- 변수를 선언한 다음에는 변수에 값을 저장하고, 참조하고 저장된 값을 변경할 수 있다
- 반드시 프로그램의 맨 앞머리에 변수 선언을 해두어야 한다

### 변수에 값 저장
```
int main(void)
{
	int num; //num이라는 이름의, int 타입의 변수를 선언
	num = 20; // 변수에 20 저장. 처음 값을 저장하는 것을 초기화라고 한다.
	printf("%d", num); // 변수 num의 값 참조해서 모니터 출력
	return 0; // 프로그램이 잘 작동되었다는 표시로 0을 return
}

```


- 변수를 선언만 하고 초기화하지 않으면 쓰레기값이 저장되므로, 0으로 초기화해주는 것이 좋다. 
- 중괄호 내 변수 선언시, 선언문은 앞부분에 위치해야 한다.

### 변수의 자료형
- 크게 정수형 변수, 실수형 변수로 나눠진다
- 정수형 변수는 크기에 따라 char, short, int, long으로 나눠지고, 실수형 변수도 크기에 따라  float, double로 나눠진다.

### 데이터 표현 방식의 이해

#### 메모리 크기의 단위

- 비트 : 컴퓨터가 표현하는 데이터의 최소단위로서 2진수 값 하나를 저장할 수 있는 메모리의 크기

- 바이트 : 8개 비트가 모여서 1바이트가 됨

- 1바이트 기준으로 정수의 표현방식을 설명하자면 8개의 비트 중 가장 앞의 비트 한 개는 부호를 표시하고 나머지 비트들은 정수의 크기를 나타낸다. 


#### 자료형
- 자료형은 두 가지로 나뉜다 정수형, 실수형

- 정수 자료형 

	- 가장 왼쪽의 비트가 부호를 나타낸다. 이 비트를 MSB(Most Signficant Bit)라고 함
	- 음의 정수는 2의 보수로 표현한다 
	
- 실수 자료형
	- 정수와 마찬가지로 가장 왼쪽의 비트가 부호를 나타낸다
	- 부동소수점을 이용해 표현한다 

- 컴퓨터는 실수를 정확하게 표현하지 못한다. 다만 근사치만을 나타낼 뿐

#### 문자

- char은 문자 표현을 위해 쓰이지만, 정수의 형태로 표현되고 실제로 저장되는 것도 정수이다. 각 alphabet에 어떤 정수가 매칭되는지는 아스키코드를 보면 알 수 있다.

- 복수 문자의 연속인 문자열은, 문자들이 저장된 연속된 메모리의 주소이다. *나중에 포인터에서 설명*

```
int main(void)
{
	char *myString = "EMCS"; 
	// "EMCS" 는 문자열상수로서, "EMCS"가 저장된 메모리 주소의 시작 번지를 알려준다. 
	// 따라서 myString이란 포인터변수가 이름 참조해올 수 있는 것이다. 
	char myChar = "A";

}

```

### 상수

- 상수 : 변경이 불가능한 데이터
- 이름이 없는 상수를 리터럴(혹은 리터럴 상수)이라 하고, 이름 있는 상수를 const상수라 한다

```
int main(void)
{
	int num = 30 + 40 //30 과 40은 리터럴 상수
	// 정수 30과 40이 메모리 공간에 상수의 형태로 저장되고
	// 두 상수를 기반으로 덧셈
	// 덧셈의 결과로 얻어진 70이 변수 num에 저장
	return 0;
}

```

### 자료형 변환

- 자동으로 되는 경우도 있고 수동으로 되는 경우도 있다
- ex) 대입연산 전달과정에서 발생하는 자동 형 변환. 예를 들면 double num1 = 24;
24라는 int를 double로 자동으로 바꿔줌
- ex) int num = 2 라고 초기화 시킨다음 double num하는 것은 강제 형변환

### 연산자

- 연산자 : 특정 연산을 요구할 때 사용하는 약속된 기호
- 대입 연산자 = 와 산술 연산자 +, -, *, /, %
- 복합 대입 연산자: *=, /=, %=, +=, -=, <<=, >>=, &=, ^=, |= 두 개의 피연산자에 대해서, 앞의 연산을 실행한다음 왼쪽 변수에 대입
- +, - 는 부호의 의미를 가지기도 한다. 

```
int main(void)
{
	int num1=2, num2=4, num3=6;
	num1 += 3; //num1 = num1 + 3;
	num2 *= 4; //num2 = num2 + 4;
	num3 %= 5; //num3 = num3 + 5;
	printf("Result: %d, %d, %d\n", num1, num2, num3)
	return 0;
}
```

- 증가, 감소 연산자: 변수에 저장된 값을 1 증가 혹은 감소시키는 경우의 연산자
- 전위 증가 : ++num, --num
- 후위 증가 : num++, num--

```
int main(void)
{
	int num1 = 12;
	int num2 = 12;
	printf("num1++: %d \n", num1++); //후위 증가
	// 후위증가란, 속한 문장을 먼저 실행한 후 변수 값을 1증가시키는 것이다
	// 따라서 여기에선 printf가 실행된 후 num1이 13이 되므로, 프린트 되는 값은 12
	printf("++num2: %d \n", ++num2); //전위 증가
	// 전위증가란,  변수 값을 1증가시킨 후 속한 문장을 실행하는 것이다
	// 따라서 여기에서 프린트되는 값은 13

	int num2 = (num1--)+2; //이런 경우는 어떡하지?
	//원래 소괄호로 묶은 문장을 먼저 실행해야하지만, 후위증가및 후위감소시에는
	//소괄호 영향 안받아 
	return 0;
}
```
- 관계연산자 : > <  == != <= >= 두 값을 비교해서 조건 만족하면 1을, 만족하지 않으면 0 반환
- 논리연산자 : && || ! 


## 입출력 함수

- 컴퓨터의 연산은 입력과 출력을 통해 이루어진다.

### 문자 입출력 함수

### 문자열 입출력 함수

- getchar : 키보드 입출력 버퍼(메모리의 한 종류)에 저장된 문자/문자열 중 한 글자 읽어옴. 버퍼가 비어있으면 키보드 입력을 기다리고 있음. 버퍼가 채워져있으면 그 문자를 반환
- getch, getche : getch는 getchar 와 비슷하지만 버퍼를 거치지 않고 입력받은 문자 한 글자를 바로 받는다. getche는 getch에 출력기능도 있음

```
int getchar(void);
```

- putchar : 문자를 모니터에 출력

```
int putchar(int c);
```

- pritnf : 출력. scanf : 입력
- scanf 함수는 공백을 기준으로 데이터의 수를 구분한다. 따라서 공백을 포함하는 문자열을 한번의 scanf 함수호 출을 통해서 읽어 들이지는 못힌다.
- scanf가 입력받는 변수 앞에는 항상 &을 쓴다. 문제열 제외

```
int main (void)
{
	int nSamp1, nSamp2, nSamp3;
	printf("세 개의 정수 입력: ");
	scanf("%d %o %x , &nSamp1, &nSamp2, &nSamp3);
	
	printf("%d %d %d \n", nSamp1, nSamp2, nSamp3);

}

```


## 반복문
 
### While 
```
while(num<3) //반복의 조건은 num<3
{
	printf("hello world/n");
	num++;
}
// while문 소괄호 안에는 반복의 조건. 이 조건이 참이되는 동안에는 중괄호 안 코드가 계속 실행된다
```
- do ~ while 문. 반복조건을 뒤에서 검사하기 때문에, 반복영역을 적어도 한 번은 실행한다

```
do //일단 밑의 실행문 적어도 한 번은 실행
{
	printf("hello world/n");
	num++;
}while(num<3)
```

### For
- 반복을 위한 변수 선언, 반복조건을 거짓으로 만들기 위한 값의 증가 및 감소를 한 데 묶음
- 반복의 횟수가 정해진 경우 while보다 유리
- 초기식(반복을 위한 변수의 선언 및 초기화), 조건식(반복의 조건을 검사), 증감식(반복의 조건을 '거짓'으로 만드는 증가 및 감소연산) 으로 이루어짐

```

int main(void)
{
	for (int num =0; num < 3; num++)
		printf("Hi~"); // 반복의 대상이 한 줄이라 중괄호 생략
	return 0;

}


for (초기식; 조건식; 증감식)
{
	//반복의 대상이 되는 문장들
}
``` 

## 조건문
### If

```
if(조건1)
{
//조건 1 만족 시 실행
}
else if(조건2)
{
//조건 2 만족 시 실행. else if 얼마든지 추가 삽입가능
}
else
{
//모두 불만족 시 실행
}
```

- 조건 연산자: if~ else 문을 일부 대체 할 수 있음

```
(num1>num2) ? (num1) : (num2) ;

(조건) ? data1 : data2
조건이 참이면 data1이 반환되고 거짓이면 data2가 반환된다

int num3 = (num1>num2) ? (num1) : (num2);
```

### 반복문 생략과 탈출

- break : break문을 가장 가까이서 감싸고 있는 반복문 하나를 빠져나온다
- continue: 실행중인 위치에 상관없이 반복문의 조건검사 위치로 이동한다. 그리고 검사결과 참이면 반복영역을 다시실행한다

```
int main(void)
{
	while(1)
	{
		if(x>20)
		break; //x>20이면 while문 탈출
	}
}

int main(void)
{
	while(1)
	{
		if(x/2==1)
		continue; // x/2==1 조건검사로 이동
	}
	
	return 0;
}
```
- break, continue 모두 if와 자주 같이 쓰이지만 if 문을 탈출하거나, if 문의 조건절로 돌아가는 것이 아니라는 것 명심

- switch문도 있는데 뭐 다 똑같아... 

```
switch(n)
{
case 1:
	printf("AAA");
	break;
case 2:
	printf("BBB");
	break;
case 3:
	printf("CCC");
	break;
default:
	printf("Hi")
}
//주의해야 될 건 case문에 break쓰는 거 (하지만 이것도 상황에 따라 선택적)
//if 문에선 else에 해당하는 게 여기선 default라는 것 정도
```
